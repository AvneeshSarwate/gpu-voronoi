
class PhotoDemoController {
    # Canvas that user sees
    var _canvas HTMLCanvasElement
    var _ctx CanvasRenderingContext2D

    # Canvas that isn't displayed to user. We pass this to the
    # Voronoi generator.
    var _seedCanvas HTMLCanvasElement
    var _seedCtx CanvasRenderingContext2D

    # Cached for performance since we use these on every draw
    var _sourceImg HTMLImageElement
    var _sourcePattern CanvasPattern

    var _isMouseDown = false
    var colorIndex = 0
    var radius = 1
    var onDraw fn()

    def new(canvas HTMLCanvasElement) {
        _canvas = canvas
        _ctx = _canvas.getContext2D
        canvas.width = DemoController.gridSize
        canvas.height = DemoController.gridSize

        _seedCanvas = document.createElement("canvas") as HTMLCanvasElement
        _seedCtx = _seedCanvas.getContext2D
        _seedCanvas.width = _canvas.width
        _seedCanvas.height = _canvas.height

        _sourceImg = document.getElementById("eye") as HTMLImageElement
        _sourcePattern = _seedCtx.createPattern(_sourceImg, "repeat")

        # Start out by drawing the source image in the canvas displayed
        # to the user
        _ctx.drawImage(_sourceImg, 0.0, 0.0)

        _canvas.addEventListener("mousedown", (e HTMLMouseEvent) => {
            _isMouseDown = true
            e.preventDefault
            e.stopPropagation
            _draw(Vector.new(e.offsetX, e.offsetY))
        })

        _canvas.addEventListener("mousemove", (e HTMLMouseEvent) => {
            if _isMouseDown {
                _draw(Vector.new(e.offsetX, e.offsetY))
            }
            e.stopPropagation
        })

        _canvas.addEventListener("mouseup", (e HTMLMouseEvent) => {
            _draw(Vector.new(e.offsetX, e.offsetY))
            _isMouseDown = false
            e.stopPropagation
        })
    }

    def seedCanvas HTMLCanvasElement { return _seedCanvas }

    def _draw(point Vector) {
        _ctx.beginPath
        _ctx.rect(
            (point.x - radius) as int,
            (point.y - radius) as int,
            radius * 2,
            radius * 2
        )
        _ctx.fillStyle = "#FFFFFF"
        _ctx.fill

        # Pin the sourceImage pixels down onto the seed canvas
        # where the user is drawing
        _seedCtx.beginPath
        _seedCtx.rect(
            (point.x - radius) as int,
            (point.y - radius) as int,
            radius * 2,
            radius * 2
        )

        const img = document.getElementById("eye") as HTMLImageElement
        const pattern = _seedCtx.createPattern(img, "repeat")
        _seedCtx.fillStyle = pattern
        _seedCtx.fill
        if onDraw != null {
            onDraw()
        }
    }

    def _styleCanvas(canvas HTMLCanvasElement) {

    }
}