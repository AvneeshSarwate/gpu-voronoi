
interface MouseBehavior {
    def down(e HTMLMouseEvent)
    def move(e HTMLMouseEvent)
    def up(e HTMLMouseEvent)
}

class DrawSeedMouseBehavior :: MouseBehavior {
    var _controller PhotoDemoController
    var _isMouseDown = false

    def down(e HTMLMouseEvent) {
        _isMouseDown = true
        e.stopPropagation
        _controller.drawAtPoint(canvasMouseLocation(_controller.inputCanvas, e))
        _controller.onDraw(_controller)
    }

    def move(e HTMLMouseEvent) {
        if _isMouseDown {
            _controller.drawAtPoint(canvasMouseLocation(_controller.inputCanvas, e))
            _controller.onDraw(_controller)
        }
        e.stopPropagation
    }

    def up(e HTMLMouseEvent) {
        _controller.drawAtPoint(canvasMouseLocation(_controller.inputCanvas, e))
        _controller.onDraw(_controller)
        _isMouseDown = false
        e.stopPropagation
    }
}

namespace SeedSpiralMouseBehavior {
    enum DragType {
        CENTER
        HANDLE
    }

    class DragContext {
        var type DragType
    }
}

namespace SeedSpiralMouseBehavior {
    const centerRadius = 6
    const handleRadius = 4
    const clickBlur = 3
    const initialCenterHandleDistance = 50.0
}

class SeedSpiralMouseBehavior :: MouseBehavior {
    var _controller PhotoDemoController

    var _relativeSeedLocations List<Vector> = []

    var _dragContext DragContext = null

    # Locations in HTML space
    var _handle Vector = Vector.new(0, 0)
    var _center Vector = Vector.new(0, 0)
    var _lastKnownMouse = Vector.new(0, 0)

    def new(controller PhotoDemoController) {
        _controller = controller

        const canvasElementRect = (_controller.inputCanvas as HTMLElement).getBoundingClientRect
        const canvasElementSize = Vector.new(canvasElementRect.width, canvasElementRect.height)

        _center = Vector.new(
            canvasElementSize.x / 2,
            canvasElementSize.y / 2
        )

        # Position the handle above the center
        _handle = _center.clone
        _handle.y -= initialCenterHandleDistance

        for radiusIndex = 0; radiusIndex < 20; radiusIndex++ {
            # Need more and more points as we get further out
            const numPoints = 10

            # Radius gets bigger as we get further out
            const radius = radiusIndex * radiusIndex

            for i = 0.0; i < numPoints; i++ {
                var x = radius * Math.cos((i / numPoints) * Math.PI * 2)
                var y = radius * Math.sin((i / numPoints) * Math.PI * 2)

                x += Math.random * 30 - 15
                y += Math.random * 30 - 15

                _relativeSeedLocations.append(Vector.new(x, y))
            }
        }

        _render
    }

    def _render {
        # Clear the controller so we can start drawing
        _controller.clearSeedCanvas

        # Draw the new seeds via the controller
        const angle = (_handle - _center).toAngleRad
        for seedLocation in _relativeSeedLocations {
            var location = seedLocation.clone

            # Scale according to how far handle is from center
            location *= Math.max(
                (_center.distanceTo(_handle) / initialCenterHandleDistance) * 2.0,
                0.5
            )

            # Rotate by the angle between _center and _handle
            location = location.rotate(angle)

            # Move according to where the center is
            location += canvasMouseLocation(_controller.inputCanvas, _center)

            _drawIfOnCanvas(location)
        }

        _drawHandleAndCenter
        _controller.onDraw(_controller)
    }

    def _drawHandleAndCenter {
        const ctx = _controller.inputContext
        const canvasHandle = canvasMouseLocation(_controller.inputCanvas, _handle)
        const canvasCenter = canvasMouseLocation(_controller.inputCanvas, _center)

        # Draw line between the center and anchor
        ctx.beginPath
        ctx.lineWidth = 1
        ctx.moveTo(canvasHandle.x as int, canvasHandle.y as int)
        ctx.lineTo(canvasCenter.x as int, canvasCenter.y as int)
        ctx.strokeStyle = "#A5A3A3"
        ctx.stroke

        # Figure out hover state
        const normalColor = "#46C9FF"
        const hoverColor = "#ACE7FF"
        const downColor = "#0F86B7"

        var centerColor = normalColor
        var handleColor = normalColor
        if _lastKnownMouse.distanceTo(_handle) < handleRadius + clickBlur {
            handleColor = _dragContext != null ? downColor : hoverColor
        } else if _lastKnownMouse.distanceTo(_center) < centerRadius + clickBlur {
            centerColor = _dragContext != null ? downColor : hoverColor
        }

        # Draw the center
        ctx.beginPath
        ctx.arc(canvasCenter.x, canvasCenter.y, centerRadius, 0, Math.PI * 2)
        ctx.fillStyle = "#FFF"
        ctx.fill
        ctx.lineWidth = 2
        ctx.strokeStyle = centerColor
        ctx.stroke

        # Draw the anchor

        const topLeft = canvasHandle - handleRadius
        ctx.beginPath
        ctx.rect(topLeft.x, topLeft.y, handleRadius * 2, handleRadius * 2)
        ctx.fillStyle = "#FFF"
        ctx.fill
        ctx.lineWidth = 2
        ctx.strokeStyle = handleColor
        ctx.stroke
    }

    def _onMove(e HTMLMouseEvent) {
        switch _dragContext.type {
            case DragType.CENTER {
                # Move both handle and center
                const handleRelativeToCenter = _handle - _center
                _center = Vector.new(e.offsetX, e.offsetY)
                _handle = _center + handleRelativeToCenter
            }
            case DragType.HANDLE {
                # Move just the handle
                _handle = Vector.new(e.offsetX, e.offsetY)
            }
        }

        _render
    }

    def down(e HTMLMouseEvent) {
        _lastKnownMouse = Vector.new(e.offsetX, e.offsetY)

        const mouseDown = Vector.new(e.offsetX, e.offsetY)
        if _handle.distanceTo(mouseDown) < handleRadius + clickBlur {
            _dragContext = DragContext.new(DragType.HANDLE)
        } else {
            _dragContext = DragContext.new(DragType.CENTER)
        }

        e.stopPropagation
        _onMove(e)
    }

    def move(e HTMLMouseEvent) {
        _lastKnownMouse = Vector.new(e.offsetX, e.offsetY)
        if _dragContext != null {
            _onMove(e)
        } else {
            # Just re-draw handle and center since their hover state
            # might have changed
            _drawHandleAndCenter
        }
        e.stopPropagation
    }

    def up(e HTMLMouseEvent) {
        _controller.drawAtPoint(canvasMouseLocation(_controller.inputCanvas, e))
        _dragContext = null
        _lastKnownMouse = Vector.new(e.offsetX, e.offsetY)
        _drawHandleAndCenter
        e.stopPropagation
    }

    def _drawIfOnCanvas(point Vector) {
        const maxWidth = _controller.seedCanvas.width
        if point.x > 0 && point.y > 0 && point.x < maxWidth && point.y < maxWidth {
            _controller.drawAtPoint(point)
        }
    }
}

class PhotoDemoController {
    # Canvas that user sees
    var inputCanvas HTMLCanvasElement
    var outputCanvas HTMLCanvasElement
    var inputContext CanvasRenderingContext2D

    # Canvas that isn't displayed to user. We pass this to the
    # Voronoi generator.
    var _seedCanvas HTMLCanvasElement
    var _seedCtx CanvasRenderingContext2D

    # Cached for performance since we use these on every draw
    var sourceImg HTMLImageElement
    var sourcePattern CanvasPattern

    var _isMouseDown = false

    # Set by someone else to hear when we draw
    var onDraw fn(PhotoDemoController)

    var _mouseBehaviors List<MouseBehavior> = []

    def new(inputCanvas_ HTMLCanvasElement, outputCanvas_ HTMLCanvasElement, onDraw_ fn(PhotoDemoController)) {
        inputCanvas = inputCanvas_
        outputCanvas = outputCanvas_
        onDraw = onDraw_
        inputContext = inputCanvas.getContext2D

        _seedCanvas = document.createElement("canvas") as HTMLCanvasElement
        _seedCtx = _seedCanvas.getContext2D
        _seedCanvas.width = inputCanvas.width
        _seedCanvas.height = inputCanvas.height

        sourceImg = document.getElementById("eye") as HTMLImageElement
        sourcePattern = _seedCtx.createPattern(sourceImg, "repeat")

        for canvas in [inputCanvas, outputCanvas] {
            canvas.addEventListener("mousedown", (e HTMLMouseEvent) => {
                for behavior in _mouseBehaviors { behavior.down(e) }
            })

            canvas.addEventListener("mousemove", (e HTMLMouseEvent) => {
                for behavior in _mouseBehaviors { behavior.move(e) }
            })

            canvas.addEventListener("mouseup", (e HTMLMouseEvent) => {
                for behavior in _mouseBehaviors { behavior.up(e) }
            })
        }

        _mouseBehaviors = [
            #DrawSeedMouseBehavior.new(self)
            SeedSpiralMouseBehavior.new(self)
        ]
    }

    def seedCanvas HTMLCanvasElement { return _seedCanvas }

    def _drawAtPoint(ctx CanvasRenderingContext2D, point Vector, fillStyle dynamic, size int) {
        ctx.beginPath
        ctx.rect(
            point.x as int,
            point.y as int,
            size,
            size
        )
        # TODO(ryan): Talk to Evan about this
        (ctx as dynamic).fillStyle = fillStyle
        ctx.fill
    }

    # Called by mouse behaviors

    def clearSeedCanvas {
        inputContext.clearRect(0, 0, inputCanvas.width, inputCanvas.height)
        _seedCtx.clearRect(0, 0, _seedCanvas.width, _seedCanvas.height)
    }

    def drawAtPoint(point Vector) {
        _drawAtPoint(inputContext, point, "rgba(255, 255, 255, 0.7)", 2)

        # Pin the sourceImage pixels down onto the seed canvas
        # where the user is drawing
        _drawAtPoint(_seedCtx, point, sourcePattern, 1)
    }
}