def sizeCanvas(canvas HTMLCanvasElement, size int) {
    canvas.width = (size * Browser.devicePixelRatio) as int
    canvas.height = (size * Browser.devicePixelRatio) as int
    canvas.style.width = "\(size)px"
    canvas.style.height = "\(size)px"
}

def getCanvas(container HTMLElement, className string, canvasSize int) HTMLCanvasElement {
    const canvas = (container as dynamic).getElementsByClassName(className)[0] as HTMLCanvasElement
    sizeCanvas(canvas, canvasSize)
    return canvas
}

def tryOrDisplayError(container HTMLElement, tryBlock fn()) {
    try {
        tryBlock()
    } catch temp dynamic {
        container.innerHTML = ""
        container.textContent = "Demo disabled. Couldn't enable WebGL."
    }
}

def initializePaintDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)

    var jfa JumpFlood = null
    tryOrDisplayError(container, => {
        jfa = JumpFlood.new(outputCanvas)
    })

    if jfa != null {
        CanvasDrawController.new(inputCanvas, outputCanvas, => {
            jfa.computeAndDraw(inputCanvas)
        })
    }
}

def initializeFishDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)

    var jfa JumpFlood = null
    tryOrDisplayError(container, => {
        jfa = JumpFlood.new(outputCanvas)
    })

    if jfa != null {
        FishGameController.new(inputCanvas, outputCanvas, => {
            const opts = JumpFlood.Options.new
            opts.wrap = true
            jfa.computeAndDraw(inputCanvas, opts)
        })
    }
}

def initializePhotoDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)

    var jfa JumpFlood = null
    tryOrDisplayError(container, => {
        jfa = JumpFlood.new(outputCanvas)
    })

    if jfa != null {
        PhotoDemoController.new(inputCanvas, outputCanvas, (photoController PhotoDemoController) => {
            jfa.computeAndDraw(photoController.seedCanvas)
        })
    }
}

def initializeDistanceDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)

    var jfa JumpFlood = null
    tryOrDisplayError(container, => {
        jfa = JumpFlood.new(outputCanvas)
    })

    if jfa != null {
        FishGameController.new(inputCanvas, outputCanvas, => {
            const opts = JumpFlood.Options.new
            opts.wrap = true
            opts.output = .DISTANCE_FIELD
            jfa.computeAndDraw(inputCanvas, opts)
        })
    }
}

def initializeShadowDemo(container HTMLElement) {
    const gridSize = 256
    const outputCanvas = getCanvas(container, "output-canvas", gridSize)
    outputCanvas.getContext2D.scale(Browser.devicePixelRatio, Browser.devicePixelRatio)
    ShadowDemoController.new(
        container,
        gridSize,
        outputCanvas,
        (container as dynamic).getElementsByClassName("shadow-spread-slider")[0],
        (container as dynamic).getElementsByClassName("shadow-blur-slider")[0]
    )
}

def initializeSliderDemo(container HTMLElement) {
    const gridSize = 256
    const inputCanvas = getCanvas(container, "input-canvas", gridSize)
    const outputCanvas = getCanvas(container, "output-canvas", gridSize)
    var jfa JumpFlood = null
    tryOrDisplayError(container, => {
        jfa = JumpFlood.new(outputCanvas)
    })

    if jfa == null {
        return
    }

    const label = (container as dynamic).getElementsByClassName("jfa-round-label")[0] as HTMLElement
    const slider = (container as dynamic).getElementsByClassName("jfa-round-slider")[0]

    const max = Math.log2(gridSize) + 1
    noUiSlider.create(slider, {
        "start": max,
        "step": 1,
        "range": {
            "min": 1,
            "max": max
        }
    })

    const drawWithSteps = (steps int) => {
        label.textContent = "Round #\(slider.noUiSlider.get() as int)"
        const opts = JumpFlood.Options.new
        opts.maxRounds = steps
        jfa.computeAndDraw(inputCanvas, opts)
    }

    slider.noUiSlider.on("slide", => {
        drawWithSteps(slider.noUiSlider.get() as int)
    })

    # A CanvasDrawController handles user draw-actions on the input canvas
    # Whenever the user draws, we re-render the voronoi diagram for the input
    CanvasDrawController.new(inputCanvas, outputCanvas, => {
        drawWithSteps(slider.noUiSlider.get() as int)
    })

    drawWithSteps(max)
}

def initializeJfaPatternDemo(element HTMLElement) {
    const canvas = (element as dynamic).getElementsByTagName("canvas")[0]
    const gridSize = 16
    sizeCanvas(canvas, 256)
    JFAPatternDemoController.new(
        canvas,
        256,
        gridSize,
        (element as dynamic).getElementsByClassName("step-size-label")[0] as HTMLElement,
        (element as dynamic).getElementsByClassName("step-size-slider")[0] as HTMLElement
    )
}

@entry
def main {
    window.addEventListener("load", => {
        initializePaintDemo(document.getElementById("paint-demo-container"))
        initializeFishDemo(document.getElementById("fish-demo-container"))
        initializePhotoDemo(document.getElementById("photo-demo-container"))
        initializeJfaPatternDemo(document.getElementById("jfa-pattern-demo-container"))
        initializeSliderDemo(document.getElementById("slider-demo-container"))
        initializeDistanceDemo(document.getElementById("distance-demo-container"))
        initializeShadowDemo(document.getElementById("shadow-demo-container"))
    })
}

