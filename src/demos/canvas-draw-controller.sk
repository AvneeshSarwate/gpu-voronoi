# This file implements a demo where the user can draw seeds in one canvas
# and see their Voronoi diagram in another canvas. Seeds have randomly
# generated (pink-ish) colors.

namespace CanvasDrawController {
    const dotRadius = 1
}

class CanvasDrawController {
    const _inputCanvas HTMLCanvasElement
    const _outputCanvas HTMLCanvasElement
    const _ctx CanvasRenderingContext2D
    const _onDraw fn()

    # onDraw will be called whenever the user draws something in the canvas.
    # Useful since we want to re-compute the Voronoi diagram of the canvas
    # every time the user draws.
    def new(inputCanvas HTMLCanvasElement, outputCanvas HTMLCanvasElement, onDraw fn()) {
        _inputCanvas = inputCanvas
        _outputCanvas = outputCanvas
        _onDraw = onDraw

        _inputCanvas.style.backgroundColor = "white"
        _ctx = _inputCanvas.getContext2D
        _ctx.scale(Browser.devicePixelRatio, Browser.devicePixelRatio)

        var isMouseDown = false

        for canvas in [_inputCanvas, _outputCanvas] {
            canvas.addEventListener("mousemove", (e HTMLMouseEvent) => {
                if isMouseDown && (e.target == _inputCanvas || e.target == _outputCanvas) {
                    _changeColorAndDraw(e.location)
                }
            })
        }

        document.addEventListener("mousedown", (e HTMLMouseEvent) => {
            if e.target == _inputCanvas || e.target == _outputCanvas {
                isMouseDown = true
                _changeColorAndDraw(e.location)
            }
        })

        document.addEventListener("mouseup", (e HTMLMouseEvent) => {
            isMouseDown = false
        })

        document.addEventListener("mouseleave", (e HTMLMouseEvent) => {
            isMouseDown = false
        })

        const canvasRect = _inputCanvas.getBoundingClientRect
        _changeColorAndDraw(Vector.new(canvasRect.width / 2, canvasRect.height / 2))
    }

    def _changeColorAndDraw(point Vector) {
        const canvasRect = _inputCanvas.getBoundingClientRect

        if point.x > 0 && point.y > 0 && point.x < canvasRect.width && point.y < canvasRect.height {
            const color = Color.new(
                0.5 + Math.random * 0.4,
                0.2,
                0.3 + Math.random * 0.5,
                1.0
            )

            _ctx.beginPath
            _ctx.rect(
                (point.x - dotRadius) as int,
                (point.y - dotRadius) as int,
                dotRadius * 2,
                dotRadius * 2
            )
            _ctx.fillStyle = color.toCSS
            _ctx.fill
            if _onDraw != null {
                _onDraw()
            }
        }
    }
}