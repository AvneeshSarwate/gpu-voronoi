precision highp float;
precision highp int;

uniform sampler2D iCellGridTexture;
uniform sampler2D iSeedInputTexture;
uniform sampler2D iInputTexture;

// Width and height of texture grid that we use to store
// JFA data
uniform vec2 iGridSize;
uniform vec2 iResolution;
uniform vec2 iCellGridSize;
uniform int iStepSize;
uniform float iMinSeedDistanceThreshold;
uniform bool iUseTorusDistanceForSeeds;

// The color that is *not* to be counted as seed.
uniform vec4 iBackgroundColor;

// Helpers
////////////////////////////////////////////////////////////////////////

const float EPSILON = 0.0001;

const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);
const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);
const vec4 CYAN = vec4(0.0, 1.0, 1.0, 1.0);
const vec4 MAGENTA = vec4(1.0, 0.0, 1.0, 1.0);
const vec4 YELLOW = vec4(1.0, 1.0, 0.0, 1.0);
const vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);

int modInt(int a, int b) {
    return int(mod(float(a), float(b)));
}

int joinInt(ivec2 ab) {
    return ab.x * 256 + ab.y;
}

ivec2 splitInt(int encoded) {
    return ivec2(encoded / 256, modInt(encoded, 256));
}

bool approxEqual(float a, float b) {
    return abs(a - b) < EPSILON;
}

bool approxEqual(vec2 a, vec2 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]);
}

bool approxEqual(vec3 a, vec3 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]) &&
        approxEqual(a[2], b[2]);
}
bool approxEqual(vec4 a, vec4 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]) &&
        approxEqual(a[2], b[2]) &&
        approxEqual(a[3], b[3]);
}

bool between(vec2 value, vec2 bottom, vec2 top) {
    return value.x > bottom.x && value.x < top.x && value.y > bottom.y && value.y < top.y;
}

bool validUv(vec2 uv) {
    return uv.x >= 0.0 && uv.y >= 0.0 && uv.x <= 1.0 && uv.y <= 1.0;
}

// Vertex shader for drawing a quad
////////////////////////////////////////////////////////////////////////

attribute vec2 quad;

export void vCopyPosition() {
    gl_Position = vec4(quad, 0, 1.0);
}

// Each pixel in our grid texture is a cell object. Each cell contains
// the following info (-1.0, seedIndex, locationX, locationY). The
// following functions are an 'object-oriented' set of functions for
// handling cells.
////////////////////////////////////////////////////////////////////////

// Output is a vec4 that can be stored in a texel. It's co-ordinates
// are from 0-1.
vec4 createCell(const ivec2 location) {
    // Store gl_FragCoord.xy in the pixel
    ivec2 rg = splitInt(location.x);
    ivec2 ba = splitInt(location.y);
    return vec4(vec2(rg) / 255., vec2(ba) / 255.);
}

// Output is a vec4 that can be stored in a texel. It's co-ordinates
// are from 0-1.
//
// This is the call with co-ordinates (~65k, ~65k)
vec4 createInvalidCell() {
    return createCell(ivec2(21000, 21000));
}

// Input is a vec4 that can be used as a texel. It's co-ordinates
// are from 0-1.
vec2 cell_closestSeed(const vec4 obj) {
    int x = joinInt(ivec2(obj.rg * 255.));
    int y = joinInt(ivec2(obj.ba * 255.));
    return vec2(x, y);
}

bool cell_isValid(const vec4 obj) {
    vec2 location = cell_closestSeed(obj);
    return location.x < 20000.0;
}

// Fragment shader for prepping an image as a set of seeds ready for JFA
////////////////////////////////////////////////////////////////////////

export void fPrepForJFA() {
    vec2 gridUv = gl_FragCoord.xy / iGridSize;
    vec2 gridUvFlippedY = vec2(gridUv.x, 1.0 - gridUv.y);
    vec4 pixel = texture2D(iSeedInputTexture, gridUvFlippedY);
    if (approxEqual(pixel, iBackgroundColor)) {
        gl_FragColor = createInvalidCell();
    } else {
        gl_FragColor = createCell(ivec2(gl_FragCoord.xy));
    }
}

// Fragment shader for the Jump Flood algorithm
////////////////////////////////////////////////////////////////////////

// Returns the distance between `a` and `b` if they're on a torus of size `torusSize`
float torusDistance(vec2 a, vec2 b, vec2 torusSize) {
    float firstPart = min(abs(a.x - b.x), torusSize.x - abs(a.x - b.x));
    float secondPart = min(abs(a.y - b.y), torusSize.y - abs(a.y - b.y));
    return sqrt(
        firstPart * firstPart + secondPart * secondPart
    );
}

vec4 compareCellWithCellAtOffset(const vec4 self, const vec2 offset) {
    vec2 gridUv = (gl_FragCoord.xy + offset) / iCellGridSize;
    vec4 otherCell = texture2D(iCellGridTexture, gridUv);

    if (!validUv(gridUv) && !iUseTorusDistanceForSeeds) {
        otherCell = createInvalidCell();
    }

    if (!cell_isValid(otherCell)) {
        // Other is invalid. This means that 'offset' is off the grid or
        // 'otherCell' doesn't have any seed info yet.
        return self;
    }

    else if (!cell_isValid(self)) {
        // Our seed location hasn't been set but other's has.
        return otherCell;
    }

    else {
        vec2 selfSeedLocation = cell_closestSeed(self);
        vec2 otherSeedLocation = cell_closestSeed(otherCell);

        float selfSeedDist = iUseTorusDistanceForSeeds ? torusDistance(selfSeedLocation, gl_FragCoord.xy, iCellGridSize) : distance(selfSeedLocation, gl_FragCoord.xy);
        float otherSeedDist = iUseTorusDistanceForSeeds ? torusDistance(otherSeedLocation, gl_FragCoord.xy, iCellGridSize) : distance(otherSeedLocation, gl_FragCoord.xy);

        if (selfSeedDist > otherSeedDist) {
            return otherCell;
        }
    }

    return self;
}

export void fJumpFlood() {
    // Find the object at this grid position
    vec2 gridUv = gl_FragCoord.xy / iCellGridSize;
    vec4 thisCell = texture2D(iCellGridTexture, gridUv);

    thisCell = compareCellWithCellAtOffset(thisCell, vec2(0, iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, 0));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(0, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, 0));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, iStepSize));

    gl_FragColor = thisCell;
}

// Fragment shader for drawing the result of the Jump Flood algorithm
////////////////////////////////////////////////////////////////////////

export void fDrawJumpFloodData() {
    vec2 gridUv = gl_FragCoord.xy / iGridSize;
    vec4 object = texture2D(iCellGridTexture, gridUv);
    vec2 seedLocation = cell_closestSeed(object) + vec2(.5);
    float dist = torusDistance(seedLocation, gl_FragCoord.xy, iGridSize);

    if (cell_isValid(object) && (iMinSeedDistanceThreshold < 0.) || (dist < iMinSeedDistanceThreshold)) {
        // Pixel shaders have fragments co-ordinates on the half pixel. We
        // lost the half pixel when encoding as an int, so add it back now
        // before we sample from the original pixel.
        vec2 gridUv = seedLocation / iGridSize;
        vec2 gridUvFlippedY = vec2(gridUv.x, 1.0 - gridUv.y);
        gl_FragColor = texture2D(iSeedInputTexture, gridUvFlippedY);
    } else {
        gl_FragColor = BLACK;
    }
}

export void fDrawDistanceField() {
    vec2 gridUv = gl_FragCoord.xy / iGridSize;

    if (!validUv(gridUv)) {
        gl_FragColor = RED;
        return;
    }

    vec4 object = texture2D(iCellGridTexture, gridUv);
    vec2 seedLocation = cell_closestSeed(object);
    float dist = torusDistance(seedLocation, gl_FragCoord.xy, iGridSize);

    // The 0.5 is made up. We just need to divide `dist` by
    // some number bigger than its maximum possible size, and
    // for our demos `iGridSize.x / 0.5` works fine.
    dist = 1.0 - (dist / (iGridSize.x * 0.5));
    gl_FragColor = vec4(dist, dist, dist, 1.0);

}

// Just renders a texture to the screen.
////////////////////////////////////////////////////////////////////////

export void fRenderTexture() {
    vec2 canvasSpaceUv = gl_FragCoord.xy / iResolution;
    gl_FragColor = texture2D(iInputTexture, canvasSpaceUv);
}