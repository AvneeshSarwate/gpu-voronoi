precision highp float;

uniform sampler2D iCellGridTexture;
uniform sampler2D iSeedInputTexture;
uniform sampler2D iInputTexture;

uniform vec2 iGridSize; // Width and height of iCellGridTexture
uniform vec2 iCanvasSize; // Size of HTML canvas element
uniform vec2 iResolution;
uniform vec2 iCellGridSize;

uniform int iRelease; // Used for debugging
uniform int iStepSize;
uniform int iAntialiasingFactor;

uniform float iMinSeedDistanceThreshold;

uniform bool iUseTorusDistanceForSeeds;

// The color that is *not* to be counted as seed.
uniform vec4 iBackgroundColor;

// Helpers
////////////////////////////////////////////////////////////////////////

const float EPSILON = 0.0001;

const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);
const vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);
const vec4 CYAN = vec4(0.0, 1.0, 1.0, 1.0);
const vec4 MAGENTA = vec4(1.0, 0.0, 1.0, 1.0);
const vec4 YELLOW = vec4(1.0, 1.0, 0.0, 1.0);
const vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);

int modInt(int a, int b) {
    return int(mod(float(a), float(b)));
}

int encodeColorValues(int a, int b) {
    return a * 256 + b;
}

vec2 decodeColorValues(int encoded) {
    return vec2(encoded / 256, modInt(encoded, 256));
}

bool approxEqual(float a, float b) {
    return abs(a - b) < EPSILON;
}

bool approxEqual(vec2 a, vec2 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]);
}

bool approxEqual(vec3 a, vec3 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]) &&
        approxEqual(a[2], b[2]);
}
bool approxEqual(vec4 a, vec4 b) {
    return
        approxEqual(a[0], b[0]) &&
        approxEqual(a[1], b[1]) &&
        approxEqual(a[2], b[2]) &&
        approxEqual(a[3], b[3]);
}

bool between(vec2 value, vec2 bottom, vec2 top) {
    return value.x > bottom.x && value.x < top.x && value.y > bottom.y && value.y < top.y;
}

vec2 gridPointFromFragCoord(vec2 fragCoord) {
    return iGridSize * gl_FragCoord.xy / iCanvasSize;
}

bool validUv(vec2 uv) {
    return uv.x >= 0.0 && uv.y >= 0.0 && uv.x <= 1.0 && uv.y <= 1.0;
}

// Vertex shader for drawing a quad
////////////////////////////////////////////////////////////////////////

attribute vec2 quad;

export void vCopyPosition() {
    gl_Position = vec4(quad, 0, 1.0);
}

// Each pixel in our grid texture is a cell object. Each cell contains
// the following info (-1.0, seedIndex, locationX, locationY). The
// following functions are an 'object-oriented' set of functions for
// handling cells.
////////////////////////////////////////////////////////////////////////

vec4 createCell(float rg, float ba, vec2 location) {
    return vec4(rg, ba, location);
}

vec4 createInvalidCell() {
    return vec4(-1.0, -1.0, -1.0, -1.0);
}

vec4 cellColor(const vec4 cell) {
    int rg = int(cell[0]);
    int ba = int(cell[1]);
    return vec4(decodeColorValues(rg), decodeColorValues(ba)) / 255.;
}

vec2 cellSeedLocation(const vec4 obj) {
    return vec2(obj[2], obj[3]);
}

bool cellIsValid(const vec4 obj) {
    return !approxEqual(obj[1], -1.0);
}

// Fragment shader for prepping an image as a set of seeds ready for JFA
////////////////////////////////////////////////////////////////////////

export void fPrepForJFA() {
    vec2 gridUv = gl_FragCoord.xy / iGridSize;
    vec2 gridUvFlippedY = vec2(gridUv.x, 1.0 - gridUv.y);
    vec4 pixel = texture2D(iSeedInputTexture, gridUvFlippedY);

    if (approxEqual(pixel, iBackgroundColor)) {
        gl_FragColor = createInvalidCell();
    } else {
        int rg = encodeColorValues(int(pixel.r * 255.), int(pixel.g * 255.));
        int ba = encodeColorValues(int(pixel.b * 255.), int(pixel.a * 255.));
        gl_FragColor = createCell(float(rg), float(ba), gl_FragCoord.xy);
    }
}

// Fragment shader for the Jump Flood algorithm
////////////////////////////////////////////////////////////////////////

// Returns the distance between `a` and `b` if they're on a torus of size `torusSize`
float torusDistance(vec2 a, vec2 b, vec2 torusSize) {
    float firstPart = min(abs(a.x - b.x), torusSize.x - abs(a.x - b.x));
    float secondPart = min(abs(a.y - b.y), torusSize.y - abs(a.y - b.y));
    return sqrt(
        firstPart * firstPart + secondPart * secondPart
    );
}

vec4 compareCellWithCellAtOffset(const vec4 self, const vec2 offset) {
    vec2 gridUv = (gl_FragCoord.xy + offset) / iCellGridSize;
    vec4 otherCell = texture2D(iCellGridTexture, gridUv);

    if (!validUv(gridUv) && !iUseTorusDistanceForSeeds) {
        otherCell = createInvalidCell();
    }

    if (!cellIsValid(otherCell)) {
        // Other is invalid. This means that 'offset' is off the grid or
        // 'otherCell' doesn't have any seed info yet.
        return self;
    }

    else if (!cellIsValid(self)) {
        // Our seed location hasn't been set but other's has.
        return otherCell;
    }

    else {
        vec2 selfSeedLocation = cellSeedLocation(self);
        vec2 otherSeedLocation = cellSeedLocation(otherCell);

        float selfSeedDist = iUseTorusDistanceForSeeds ? torusDistance(selfSeedLocation, gl_FragCoord.xy, iCellGridSize) : distance(selfSeedLocation, gl_FragCoord.xy);
        float otherSeedDist = iUseTorusDistanceForSeeds ? torusDistance(otherSeedLocation, gl_FragCoord.xy, iCellGridSize) : distance(otherSeedLocation, gl_FragCoord.xy);

        if (selfSeedDist > otherSeedDist) {
            return otherCell;
        }
    }

    return self;
}

export void fJumpFlood() {
    // Find the object at this grid position
    vec2 gridUv = gl_FragCoord.xy / iCellGridSize;
    vec4 thisCell = texture2D(iCellGridTexture, gridUv);

    thisCell = compareCellWithCellAtOffset(thisCell, vec2(0, iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, 0));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(iStepSize, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(0, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, - iStepSize));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, 0));
    thisCell = compareCellWithCellAtOffset(thisCell, vec2(- iStepSize, iStepSize));

    gl_FragColor = thisCell;
}

// Fragment shader for drawing the result of the Jump Flood algorithm
////////////////////////////////////////////////////////////////////////

void drawDebugUI(vec2 gridPoint) {
    if (iRelease == 1) {
        return;
    }

    vec4 lightRed = vec4(1.0, 0.5, 0.5, 1.0);
    vec4 lightBlue = vec4(0.5, 0.5, 1.0, 1.0);
    vec4 lightGreen = vec4(0.5, 1.0, 0.5, 1.0);

    // Show a red 100x100 cell grid
    if (mod(gridPoint.x, 100.0) < 3.0 || mod(gridPoint.y, 100.0) < 3.0) {
        gl_FragColor = (lightRed + gl_FragColor) / 2.0;
    }

    // Show a green marker at (0, 0)
    if (between(gridPoint.xy, vec2(0.0, 0.0), vec2(10.0, 10.0))) {
        gl_FragColor = (lightGreen + gl_FragColor) / 2.0;
    }

    // Show a blue marker at (100, 100)
    if (between(gridPoint.xy, vec2(100.0, 100.0), vec2(110.0, 110.0))) {
        gl_FragColor = (lightBlue + gl_FragColor) / 2.0;
    }
}

export void fDrawJumpFloodData() {
    vec2 gridPoint = gridPointFromFragCoord(gl_FragCoord.xy);
    vec2 gridUv = gridPoint / iGridSize;

    if (!validUv(gridUv)) {
        gl_FragColor = BLACK;
        drawDebugUI(gridPoint);
        return;
    }

    vec4 object = texture2D(iCellGridTexture, gridUv);
    if (!cellIsValid(object)) {
        discard;
    } else if ((iMinSeedDistanceThreshold > 0.0 ) && (distance(cellSeedLocation(object), gridPoint) > iMinSeedDistanceThreshold)) {
        gl_FragColor = BLACK;
    } else {
        gl_FragColor = cellColor(object);
    }
}

export void fDrawDistanceField() {
    vec2 gridPoint = gridPointFromFragCoord(gl_FragCoord.xy);
    vec2 gridUv = gridPoint / iGridSize;

    if (!validUv(gridUv)) {
        gl_FragColor = BLACK;
        drawDebugUI(gridPoint);
        return;
    }

    vec4 object = texture2D(iCellGridTexture, gridUv);
    if (!cellIsValid(object)) {
        discard;
    } else {
        vec2 seedLocation = cellSeedLocation(object);
        float dist = torusDistance(seedLocation, gridPoint, iGridSize);

        // The 0.5 is made up. We just need to divide `dist` by
        // some number bigger than its maximum possible size, and
        // for our demos `iGridSize.x / 0.5` works fine.
        dist = 1.0 - (dist / (iGridSize.x * 0.5));
        gl_FragColor = vec4(dist, dist, dist, 1.0);
    }
}

// Just renders a texture to the screen.
////////////////////////////////////////////////////////////////////////

export void fRenderTexture() {
    vec2 canvasSpaceUv = gl_FragCoord.xy / iResolution;
    gl_FragColor = texture2D(iInputTexture, canvasSpaceUv);
}