def getWebGLExtension(gl WebGLRenderingContext, name string) dynamic {
    const ext = gl.getExtension(name)
    if ext == null {
        throw Error.new("Unsupported WebGL extension with name \(name)")
    }
    return ext
}

const colors List<Color> = [
    Color.fromHex(0x6C88FF),
    Color.fromHex(0x42D1FF),
    Color.fromHex(0xB841D7),
    Color.fromHex(0x9825FF),
    Color.fromHex(0x5EFFFC),
    Color.fromHex(0x49FFA9),
    Color.fromHex(0x7E6EFF),
    Color.fromHex(0xA0FFCE),
    Color.fromHex(0xE854FF),
]

class JumpFlood {
    var _igloo Igloo

    # Width and height of the grid that we run JFA on. Always a square
    # and a power of two since it's the size of a WebGL texture.
    var _gridSize int

    var _program Igloo.Program
    var _prepProgram Igloo.Program
    var _quadBuffer Igloo.Buffer
    var _sourceTexture Igloo.Texture
    var _destTexture Igloo.Texture
    var _tmpTexture Igloo.Texture
    var _framebuffer Igloo.FrameBuffer
    var _simulationStepper dynamic

    var _drawOutput Igloo.Program
    var _outputCanvas HTMLCanvasElement

    # Read-only properties
    def outputTexture Igloo.Texture { return _sourceTexture }

    def new(canvas HTMLCanvasElement, gridSize int) {
        _gridSize = gridSize
        _outputCanvas = canvas

        # Igloo is a thin object-oriented WebGL library. TODO(ryan): move
        # this initialization into `lib`.
        _igloo = Igloo.new(canvas)
        if _igloo.gl == null {
            throw Error.new("Failed to initialize Igloo")
        }

        _igloo.gl.disable(_igloo.gl.DEPTH_TEST)
        _drawOutput = Igloo.Program.new(_igloo.gl, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_DRAW_GRID)

        var gl = _igloo.gl
        getWebGLExtension(gl, "OES_texture_float")
        gl.disable(gl.DEPTH_TEST)

        _program = Igloo.Program.new(_igloo.gl, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_JUMP_FLOOD)
        _prepProgram = Igloo.Program.new(_igloo.gl, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_PREP_FOR_JFA)
        _quadBuffer = _igloo.array(Igloo.QUAD2)
        _sourceTexture = _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT).blank(gridSize, gridSize)
        _destTexture = _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT).blank(gridSize, gridSize)
        _tmpTexture = _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.UNSIGNED_BYTE).blank(gridSize, gridSize)
        _framebuffer = _igloo.framebuffer
        _setSeeds(Seed.random(Vector.new(DemoController.gridSize, DemoController.gridSize), colors, 200))
    }

    def drawToOutputCanvas {
        _igloo.defaultFramebuffer.bind
        _destTexture.bind(0)
        _igloo.gl.viewport(0, 0, _outputCanvas.width, _outputCanvas.height)
        _drawOutput
                    .use
                    .attrib("quad", _quadBuffer, 2)
                    .uniformi("iCellGridTexture", 0)
                    .uniform("iCanvasSize", Float32Array.new([_outputCanvas.width, _outputCanvas.height]))
                    .uniform("iGridSize", Float32Array.new([_gridSize, _gridSize]))
                    .uniform("iRelease", RELEASE, true)
                    .draw(_igloo.gl.TRIANGLE_STRIP, 4)
    }

    def setSeedsFromCanvas(inputCanvas HTMLCanvasElement) {
        _framebuffer.attach(_sourceTexture)

        if !RELEASE {
            const gl = _igloo.gl
            var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
            if check != gl.FRAMEBUFFER_COMPLETE {
                throw Error.new("Framebuffer completion issue")
            }
        }

        # Create a texture for the canvas. Bind it to texture position 0.
        const gl = _igloo.gl
        gl.bindTexture(gl.TEXTURE_2D, _tmpTexture.texture)
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, inputCanvas)
        _tmpTexture.bind(0)

        _igloo.gl.viewport(0, 0, _gridSize, _gridSize)
        _prepProgram
                    .use
                    .attrib("quad", _quadBuffer, 2)
                    .uniformi("iCellGridTexture", 0)
                    .uniform("iCellGridSize", Float32Array.new([_gridSize, _gridSize]))
                    .uniform("iBackgroundColor", Float32Array.new([0, 0, 0, 0]))
                    .draw(_igloo.gl.TRIANGLE_STRIP, 4)
    }

    def _setSeeds(seeds List<Seed>) {
        # Seeds are encoded in the grid as a vec4 (seedRg, seedBa, seedLocationX, seedLocationY)
        var rgba = Float32Array.new(_gridSize * _gridSize * 4)

        # Set all values to -1 to that it's clear that they're all uninitialized
        for i in 0..rgba.length {
            rgba[i] = -1.0
        }

        # Initialize the seeds
        for i in 0..seeds.count {
            const seed = seeds[i]
            const coord = ((seed.position.y * _gridSize + seed.position.x) * 4) as int
            const rg = Color.encodeColorValues((seed.color.r * 255) as int, (seed.color.g * 255) as int)
            const ba = Color.encodeColorValues((seed.color.b * 255) as int, (seed.color.a * 255) as int)

            rgba[coord] = rg
            rgba[coord + 1] = ba
            rgba[coord + 2] = seed.position.x
            rgba[coord + 3] = seed.position.y
        }
        _sourceTexture.subset(rgba, 0, 0, _gridSize, _gridSize)
    }

    # Useful if you want to compute Voronoi in one step.
    def computeVoronoi {
        var stepSize int = _gridSize / 2
        while stepSize >= 1 {
            _runJumpFloodStep(stepSize)
            stepSize /= 2
        }
        _runJumpFloodStep(2)
        _runJumpFloodStep(1)
    }

    # Use resetVoronoiSteps and stepVoronoi to move foward
    # through iterations of the JFA algorithm. Useful, for
    # example, if you're showing an explanation of the
    # algorithm.
    def resetVoronoiSteps {
        var stepSize int = _gridSize / 2
        _simulationStepper = () => {
            if stepSize >= 1 {
                _runJumpFloodStep(stepSize)
                stepSize /= 2
            } else if stepSize < 1 {
                for i in 1..10 {
                    _runJumpFloodStep(11 - i)
                }
            }
        }
    }

    def stepVoronoi {
        _simulationStepper()
    }

    def _runJumpFloodStep(stepSize int) {
        # The current simulation state is always in _sourceTexture
        # and we draw onto _destTexture. So...
        #
        # 1. Bind the _destTexture onto the framebuffer so that
        #    we'll draw onto it.
        #
        # 2. Bind _sourceTexture texture to index 0. This is
        #    passed to the shader by setting the
        #    cellGridTexture uniform below.
        #
        _framebuffer.attach(_destTexture)

        if !RELEASE {
            const gl = _igloo.gl
            var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
            if check != gl.FRAMEBUFFER_COMPLETE {
                throw Error.new("Framebuffer completion issue")
            }
        }

        _sourceTexture.bind(0)
        _igloo.gl.viewport(0, 0, _gridSize, _gridSize)
        _program
            .use
            .attrib("quad", _quadBuffer, 2)
            .uniformi("iCellGridTexture", 0)
            .uniformi("iStepSize", stepSize)
            .uniform("iCellGridSize", Float32Array.new([_gridSize, _gridSize]))
            .draw(_igloo.gl.TRIANGLE_STRIP, 4)

        self._swapBuffers
    }

    def _swapBuffers {
        # Swap the source and destination textures
        const tmp = _sourceTexture
        _sourceTexture = _destTexture
        _destTexture = tmp
    }

    # # Example use - Draw a single pixel at point
    # point = point.clone
    # point.x = Math.max(Math.min(point.x, gridSize), 0)
    # point.y = Math.max(Math.min(point.y, gridSize), 0)
    # const sample = Float32Array.new([1])
    # _drawOntoGrid(sample, point.x as int, point.y as int)
    #
    def _drawOntoGrid(inputGrid Float32Array, offsetX int, offsetY int) {
        const textureWidth = (Math.sqrt(inputGrid.length) as int)
        const textureHeight = textureWidth
        var rgba = Float32Array.new(textureWidth * textureWidth * 4)
        for i in 0..inputGrid.length {
            var j = i * 4
            rgba[j + 0] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 1] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 2] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 3] = 1.0
        }
        _sourceTexture.subset(rgba, offsetX, offsetY, textureWidth, textureHeight)
    }
}