def getWebGLExtension(gl WebGLRenderingContext, name string) dynamic {
    const ext = gl.getExtension(name)
    if ext == null {
        throw Error.new("Unsupported WebGL extension with name \(name)")
    }
    return ext
}

# See here to understand how this works:
# http://www.skorks.com/2010/10/write-a-function-to-determine-if-a-number-is-a-power-of-2/
def isPowerOfTwo(number int) bool {
    return number != 0 && ((number & (number - 1)) == 0)
}

namespace JumpFlood {
    class Options {
        var wrap = false
        var antialiasingFactor = 1
    }
}

class JumpFlood {
    const _options Options
    var _wham Wham

    # Width and height of the JFA canvas. Must be a power of two becuase
    # its the size of a WebGL texture.
    var _canvasSize int

    var _program Wham.Program
    var _prepProgram Wham.Program
    var _quadBuffer Wham.Buffer
    var _sourceTexture Wham.Texture
    var _destTexture Wham.Texture
    var _seedInputTexture Wham.Texture
    var _framebuffer Wham.Framebuffer
    var _simulationStepper dynamic

    var _drawOutput Wham.Program
    var _outputCanvas HTMLCanvasElement

    def new(canvas HTMLCanvasElement, options Options) {
        if canvas.width != canvas.height {
            throw Error.new("JumpFlood canvas parameter must be square. Size is (\(canvas.width), \(canvas.height))")
        }

        if !isPowerOfTwo(canvas.width) {
            throw Error.new("JumpFlood canvas size must be a power of two. Size is \(canvas.width)")
        }

        _options = options
        _canvasSize = canvas.width
        _outputCanvas = canvas

        _wham = Wham.new(canvas)
        if _wham.ctx == null {
            throw Error.new("Failed to initialize Wham")
        }

        _wham.ctx.disable(_wham.ctx.DEPTH_TEST)
        _drawOutput = Wham.Program.new(_wham.ctx, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_DRAW_GRID)

        const ctx = _wham.ctx
        getWebGLExtension(ctx, "OES_texture_float")
        ctx.disable(ctx.DEPTH_TEST)

        _program = Wham.Program.new(_wham.ctx, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_JUMP_FLOOD)
        _prepProgram = Wham.Program.new(_wham.ctx, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_PREP_FOR_JFA)

        _quadBuffer = Wham.Buffer.new(ctx)
        _quadBuffer.update(Wham.QUAD2, ctx.STATIC_DRAW)

        var opts = Wham.TextureOptions.new(ctx, ctx.RGBA, ctx.REPEAT, ctx.NEAREST, ctx.FLOAT)
        _sourceTexture = Wham.Texture.new(ctx, opts)
        _sourceTexture.clear(_gridSize, _gridSize)
        _destTexture = Wham.Texture.new(ctx, opts)
        _destTexture.clear(_gridSize, _gridSize)

        opts = Wham.TextureOptions.new(ctx, ctx.RGBA, ctx.REPEAT, ctx.NEAREST, ctx.UNSIGNED_BYTE)
        _seedInputTexture = Wham.Texture.new(ctx, opts)
        _seedInputTexture.clear(_canvasSize, _canvasSize)

        _framebuffer = Wham.Framebuffer.create(ctx)
    }

    def _gridSize int {
        return _canvasSize * _options.antialiasingFactor
    }

    def setSeedsFromCanvas(inputCanvas HTMLCanvasElement) {
        _framebuffer.attach(_sourceTexture)

        if !RELEASE {
            const ctx = _wham.ctx
            var check = ctx.checkFramebufferStatus(ctx.FRAMEBUFFER)
            if check != ctx.FRAMEBUFFER_COMPLETE {
                throw Error.new("Framebuffer completion issue")
            }
        }

        # Create a texture for the canvas. Bind it to texture position 0.
        _seedInputTexture.set(inputCanvas)
        _seedInputTexture.bind(0)

        _wham.ctx.viewport(0, 0, _gridSize, _gridSize)
        _prepProgram
                    .use
                    .attrib("quad", _quadBuffer, 2)
                    .uniform("iSeedInputTexture", 0)
                    .uniform("iGridSize", Float32Array.new([_gridSize, _gridSize]))
                    .uniform("iBackgroundColor", Float32Array.new([0, 0, 0, 0]))
                    .draw(_wham.ctx.TRIANGLE_STRIP, 4)
    }

    def drawToOutputCanvas {
        _wham.defaultFramebuffer.bind
        _destTexture.bind(0)
        _wham.ctx.viewport(0, 0, _outputCanvas.width, _outputCanvas.height)
        _drawOutput
                    .use
                    .attrib("quad", _quadBuffer, 2)
                    .uniform("iCellGridTexture", 0)
                    .uniform("iCanvasSize", Float32Array.new([_outputCanvas.width, _outputCanvas.height]))
                    .uniform("iGridSize", Float32Array.new([_gridSize, _gridSize]))
                    .uniform("iRelease", RELEASE ? 1 : 0)
                    .uniform("iAntialiasingFactor", _options.antialiasingFactor)
                    .draw(_wham.ctx.TRIANGLE_STRIP, 4)
    }

    # Useful if you want to compute Voronoi in one step.
    def computeVoronoi {
        var stepSize int = _gridSize / 2
        while stepSize >= 1 {
            _runJumpFloodStep(stepSize)
            stepSize /= 2
        }
        _runJumpFloodStep(2)
        _runJumpFloodStep(1)
    }

    # Use resetVoronoiSteps and stepVoronoi to move foward
    # through iterations of the JFA algorithm. Useful, for
    # example, if you're showing an explanation of the
    # algorithm.
    def resetVoronoiSteps {
        var stepSize int = _gridSize / 2
        _simulationStepper = () => {
            if stepSize >= 1 {
                _runJumpFloodStep(stepSize)
                stepSize /= 2
            } else if stepSize < 1 {
                for i in 1..10 {
                    _runJumpFloodStep(11 - i)
                }
            }
        }
    }

    def stepVoronoi {
        _simulationStepper()
    }

    def _runJumpFloodStep(stepSize int) {
        # The current simulation state is always in _sourceTexture
        # and we draw onto _destTexture. So...
        #
        # 1. Bind the _destTexture onto the framebuffer so that
        #    we'll draw onto it.
        #
        # 2. Bind _sourceTexture texture to index 0. This is
        #    passed to the shader by setting the
        #    cellGridTexture uniform below.
        #
        _framebuffer.attach(_destTexture)

        if !RELEASE {
            const gl = _wham.ctx
            var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
            if check != gl.FRAMEBUFFER_COMPLETE {
                throw Error.new("Framebuffer completion issue")
            }
        }

        _sourceTexture.bind(0)
        _wham.ctx.viewport(0, 0, _gridSize, _gridSize)
        _program
            .use
            .attrib("quad", _quadBuffer, 2)
            .uniform("iCellGridTexture", 0)
            .uniform("iStepSize", stepSize)
            .uniform("iCellGridSize", Float32Array.new([_gridSize, _gridSize]))
            .uniform("iUseTorusDistanceForSeeds", _options.wrap ? 1 : 0)
            .draw(_wham.ctx.TRIANGLE_STRIP, 4)

        self._swapBuffers
    }

    def _swapBuffers {
        # Swap the source and destination textures
        const tmp = _sourceTexture
        _sourceTexture = _destTexture
        _destTexture = tmp
    }
}