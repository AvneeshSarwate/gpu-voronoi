
# TODO(ryan): If we want things to look smooth on Retina displays we should
# set canvas.width to devicePixelRatio * sizeUsedInCSS. But doing so makes
# things laggy on a Macbook Air. So let's improve performance before we do
# that.
def sizeCanvas(canvas HTMLCanvasElement, size int) {
    canvas.width = (size * Browser.devicePixelRatio) as int
    canvas.height = (size * Browser.devicePixelRatio) as int
    canvas.style.width = "\(size)px"
    canvas.style.height = "\(size)px"
}

def getCanvas(container HTMLElement, className string, canvasSize int) HTMLCanvasElement {
    const canvas = (container as dynamic).getElementsByClassName(className)[0] as HTMLCanvasElement
    sizeCanvas(canvas, canvasSize)
    return canvas
}

# Builds a Voronoi generator and displays an error on the page if we can't
# (likely because this browser doesn't support WebGL).
def createVoronoiGenerator(outputCanvas HTMLCanvasElement, options Voronoi.Options) Voronoi {
    var voronoi Voronoi = null
    try {
        voronoi = Voronoi.new(outputCanvas, options)
    } catch temp dynamic {
        # Failed to initialize Web-GL. Display error.
        document.getElementById("demo-page").style.display = "none"
        document.getElementById("webgl-error").style.display = null
        throw temp
    }
    return voronoi
}

def initializePaintDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)
    const opts = Voronoi.Options.new
    const voronooi = createVoronoiGenerator(outputCanvas, opts)

    # A CanvasDrawController handles user draw-actions on the input canvas
    # Whenever the user draws, we re-render the voronoi diagram for the input
    CanvasDrawController.new(inputCanvas, outputCanvas, => {
        voronooi.setSeedsFromCanvas(inputCanvas)
        voronooi.computeVoronoi
        voronooi.drawToOutputCanvas
    })
}

def initializeFishDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)
    const opts = Voronoi.Options.new
    opts.wrap = true
    const voronoi = createVoronoiGenerator(outputCanvas, opts)

    FishGameController.new(inputCanvas, outputCanvas, => {
        voronoi.setSeedsFromCanvas(inputCanvas)
        voronoi.computeVoronoi
        voronoi.drawToOutputCanvas
    })
}

def initializePhotoDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)
    const opts = Voronoi.Options.new
    const voronoi = createVoronoiGenerator(outputCanvas, opts)

    PhotoDemoController.new(inputCanvas, outputCanvas, (photoController PhotoDemoController) => {
        voronoi.setSeedsFromCanvas(photoController.seedCanvas)
        voronoi.computeVoronoi
        voronoi.drawToOutputCanvas
    })
}

def initializeDistanceDemo(container HTMLElement) {
    const inputCanvas = getCanvas(container, "input-canvas", 256)
    const outputCanvas = getCanvas(container, "output-canvas", 256)
    const opts = Voronoi.Options.new
    opts.wrap = true
    const voronoi = createVoronoiGenerator(outputCanvas, opts)

    FishGameController.new(inputCanvas, outputCanvas, => {
        voronoi.setSeedsFromCanvas(inputCanvas)
        voronoi.computeVoronoi
        voronoi.drawDistanceFieldToOutputCanvas
    })
}

def initializeShadowDemo(container HTMLElement) {
    # Initialize canvasses
    const gridSize = 256
    const inputCanvas = getCanvas(container, "input-canvas", gridSize)
    const outputCanvas = getCanvas(container, "output-canvas", gridSize)
    const outputCanvasCtx = outputCanvas.getContext2D
    outputCanvasCtx.scale(Browser.devicePixelRatio, Browser.devicePixelRatio)
    const shadowCanvas = document.createElement("canvas") as HTMLCanvasElement
    sizeCanvas(shadowCanvas, gridSize)

    # Initialize sliders
    const spreadSlider = (container as dynamic).getElementsByClassName("shadow-spread-slider")[0]
    const blurSlider = (container as dynamic).getElementsByClassName("shadow-blur-slider")[0]

    const opts = Voronoi.Options.new
    const voronoi = createVoronoiGenerator(shadowCanvas, opts)
    const controller = DraggableTextDemoController.new(inputCanvas, outputCanvas)

    const minShadowSpread = 1
    const minShadowBlur = 1
    var shadowSpread = minShadowSpread
    var shadowBlur = 22

    var renderOutputCanvas = (shadowSpread double, shadowBlur double, offset Vector) => {
        voronoi.setSeedsFromCanvas(inputCanvas, Float32Array.new([1.0, 1.0, 1.0, 1.0]))
        voronoi.computeVoronoi
        voronoi.drawShadowToOutputCanvas(shadowSpread, shadowBlur)

        # Output canvas has a white background
        outputCanvasCtx.fillStyle = "white"
        outputCanvasCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height)

        # Draw the shadow of the text on the background
        outputCanvasCtx.drawImage(
            shadowCanvas,
            0,
            0,
            outputCanvas.width / Browser.devicePixelRatio,
            outputCanvas.height / Browser.devicePixelRatio
        )

        # Draw the text to the center of the output canvas
        controller.drawTextToContext(outputCanvasCtx, controller.center)
    }

    controller.onDraw = => {
        renderOutputCanvas(shadowSpread, shadowBlur, controller.lastKnownOffset)
    }

    noUiSlider.create(spreadSlider, {
        "start": shadowSpread,
        "range": {
            "min": minShadowSpread,
            "max": 250
        }
    })

    spreadSlider.noUiSlider.on("slide", => {
        shadowSpread = spreadSlider.noUiSlider.get()
        renderOutputCanvas(shadowSpread, shadowBlur, controller.lastKnownOffset)
    })

    noUiSlider.create(blurSlider, {
        "start": shadowBlur,
        "range": {
            "min": minShadowBlur,
            "max": 125
        }
    })

    blurSlider.noUiSlider.on("slide", => {
        shadowBlur = blurSlider.noUiSlider.get()
        renderOutputCanvas(shadowSpread, shadowBlur, controller.lastKnownOffset)
    })

    renderOutputCanvas(shadowSpread, shadowBlur, controller.lastKnownOffset)
}

def initializeSliderDemo(container HTMLElement) {
    const gridSize = 256
    const inputCanvas = getCanvas(container, "input-canvas", gridSize)
    const outputCanvas = getCanvas(container, "output-canvas", gridSize)
    const opts = Voronoi.Options.new
    const voronooi = createVoronoiGenerator(outputCanvas, opts)

    const label = (container as dynamic).getElementsByClassName("jfa-round-label")[0] as HTMLElement
    const slider = (container as dynamic).getElementsByClassName("jfa-round-slider")[0]

    const max = Math.log2(gridSize) + 1
    noUiSlider.create(slider, {
        "start": max,
        "step": 1,
        "range": {
            "min": 1,
            "max": max
        }
    })

    const drawWithSteps = (steps int) => {
        label.textContent = "Round #\(slider.noUiSlider.get() as int)"
        voronooi.setSeedsFromCanvas(inputCanvas)
        voronooi.resetVoronoiSteps
        for i in 0..steps {
            voronooi.stepVoronoi
        }
        voronooi.drawToOutputCanvas
    }

    slider.noUiSlider.on("slide", => {
        drawWithSteps(slider.noUiSlider.get() as int)
    })

    # A CanvasDrawController handles user draw-actions on the input canvas
    # Whenever the user draws, we re-render the voronoi diagram for the input
    CanvasDrawController.new(inputCanvas, outputCanvas, => {
        drawWithSteps(slider.noUiSlider.get() as int)
    })

    drawWithSteps(max)
}

def initializeJfaPatternDemo(element HTMLElement) {
    const canvas = (element as dynamic).getElementsByTagName("canvas")[0]
    const gridSize = 16
    sizeCanvas(canvas, 256)
    const controller = JFAPatternDemoController.new(canvas, 256, gridSize)
    const slider = (element as dynamic).getElementsByClassName("step-size-slider")[0]
    const label = (element as dynamic).getElementsByClassName("step-size-label")[0] as HTMLElement

    const max = JFAPatternDemoController.computeMaxRoundInclusive(gridSize)
    noUiSlider.create(slider, {
        "start": 0,
        "step": 1,
        "range": {
            "min": 0,
            "max": max
        }
    })

    # 2 way data binding between slider and simulation

    var updateLabel = (round int) => {
        const stepLength = JFAPatternDemoController.computeStepLength(round, gridSize)
        label.textContent = "JFA round \(round), step length is \(stepLength)"
    }


    var uiToModel = (round int) => {
        updateLabel(round)
        controller.state.jfaRound = round
    }

    var modelToUi = (round int) => {
        updateLabel(round)

    }

    var isUserDragging = false
    slider.noUiSlider.on("start", => {
        isUserDragging = true
    })

    slider.noUiSlider.on("end", => {
        uiToModel(slider.noUiSlider.get() as int)
        isUserDragging = false
    })

    slider.noUiSlider.on("slide", => {
        uiToModel(slider.noUiSlider.get() as int)
    })

    controller.onJfaRoundChange = => {
        if !isUserDragging {
            modelToUi(controller.state.jfaRound)
            slider.noUiSlider.set(controller.state.jfaRound)
        }
    }

    modelToUi(0)
}

@entry
def main {
    window.addEventListener("load", => {
        initializePaintDemo(document.getElementById("paint-demo-container"))
        initializeFishDemo(document.getElementById("fish-demo-container"))
        initializePhotoDemo(document.getElementById("photo-demo-container"))
        initializeJfaPatternDemo(document.getElementById("jfa-pattern-demo-container"))
        initializeSliderDemo(document.getElementById("slider-demo-container"))
        initializeDistanceDemo(document.getElementById("distance-demo-container"))
        initializeShadowDemo(document.getElementById("shadow-demo-container"))
    })
}

