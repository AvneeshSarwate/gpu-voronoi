def getWebGLExtension(gl WebGLRenderingContext, name string) dynamic {
    const ext = gl.getExtension(name)
    if ext == null {
        throw Error.new("Unsupported WebGL extension with name \(name)")
    }
    return ext
}

def nextPowerOfTwo(value int) int {
    var val = 1
    while val < value {
        val *= 2
    }
    return val
}

def powerOfTwoGridSizeToFitValues(numValues int) int {
    var val = 1
    while val * val < numValues {
        val *= 2
    }
    return val
}

class Seed {
    var position Vector
    var color Color
}

namespace Seed {
    def random(gridSize Vector, colors List<Color>) Seed {
        return Seed.new(
            Vector.new(gridSize.x * Math.random, gridSize.y * Math.random),
            colors[(Math.random * colors.count) as int]
        )
    }

    def random(gridSize Vector, colors List<Color>, numSeeds int) List<Seed> {
        var seeds List<Seed> = []
        for i in 0..numSeeds {
            seeds.append(Seed.random(gridSize, colors))
        }
        return seeds
    }
}

const colors List<Color> = [
    Color.fromHex(0x6C88FF),
    Color.fromHex(0x42D1FF),
    # Color.fromHex(0xB841D7),
    # Color.fromHex(0x9825FF),
    # Color.fromHex(0x5EFFFC),
    # Color.fromHex(0x49FFA9),
    # Color.fromHex(0x7E6EFF),
    # Color.fromHex(0xA0FFCE),
    # Color.fromHex(0xE854FF),
]

class JumpFlood {
    var _igloo Igloo

    # Width and height of Game of Life grid. It's always square.
    var gridSize int

    var _program Igloo.Program
    var _quadBuffer Igloo.Buffer
    var _sourceTexture Igloo.Texture
    var _destTexture Igloo.Texture
    var _seedTexture Igloo.Texture
    var _framebuffer Igloo.FrameBuffer
    var _simulationStepper dynamic

    var seeds = [
        Seed.new(Vector.new(5, 5), colors[0]),
        Seed.new(Vector.new(100, 100), colors[1])
    ]

    var _seedTextureSize int

    def new(igloo Igloo, gridSize_ int) {
        _igloo = igloo
        gridSize = gridSize_

        var gl = _igloo.gl
        getWebGLExtension(gl, "OES_texture_float")
        gl.disable(gl.DEPTH_TEST)

        _program = Igloo.Program.new(_igloo.gl, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_GAME_OF_LIFE)
        _quadBuffer = igloo.array(Igloo.QUAD2)
        _sourceTexture = _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT).blank(gridSize, gridSize)
        _destTexture = _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.FLOAT).blank(gridSize, gridSize)
        _framebuffer = _igloo.framebuffer

        # _seedTexture - the pixel at (i, 0) is the color of the i'th seed
        # TODO(ryan): make this a square texture
        _seedTextureSize = powerOfTwoGridSizeToFitValues(seeds.count)
        _seedTexture =
            _igloo.texture(null, gl.RGBA, gl.REPEAT, gl.NEAREST, gl.UNSIGNED_BYTE)
            .blank(_seedTextureSize, _seedTextureSize)

        var seedsRgba = Uint8Array.new(_seedTextureSize * _seedTextureSize * 4)
        for i in 0..seeds.count {
            const index = i * 4
            seedsRgba[index] = (255.0 * seeds[i].color.r) as int
            seedsRgba[index + 1] = (255.0 * seeds[i].color.g) as int
            seedsRgba[index + 2] = (255.0 * seeds[i].color.b) as int
            seedsRgba[index + 3] = (255.0 * seeds[i].color.a) as int
        }
        console.log(seedsRgba)
        _seedTexture.subset(seedsRgba, 0, 0, _seedTextureSize, _seedTextureSize)

        # Seeds are encoded in the grid as a 4-type (isSeed, seedTextureIndex, seedLocationX, seedLocationY)
        var rgba = Float32Array.new(gridSize * gridSize * 4)

        for i in 0..rgba.length {
            if i % 4 == 0 {
                # isSeed defaults to false
                rgba[i] = 0.0
            } else {
                # All other fields default to -1
                rgba[i] = -1.0
            }
        }

        # Fill the rest with seed objects as described above
        for i in 0..seeds.count {
            const seed = seeds[i]
            const coord = ((seed.position.x * gridSize + seed.position.y) * 4) as int
            rgba[coord] = 1.0 # isSeed = true
            rgba[coord + 1] = i
            rgba[coord + 2] = seed.position.x
            rgba[coord + 3] = seed.position.y
        }
        _sourceTexture.subset(rgba, 0, 0, gridSize, gridSize)
    }

    def gridTexture Igloo.Texture {
        return _sourceTexture
    }

    def seedTexture Igloo.Texture {
        return _seedTexture
    }

    def seedTextureSize int {
        return _seedTextureSize
    }

    def userClickGridSpace(point Vector) {
        # Advance to next step
        if _simulationStepper == null {
            var stepSize int = gridSize / 2

            _simulationStepper = () => {
                if stepSize >= 1 {
                    runJumpFloodStep(stepSize)
                    stepSize /= 2
                } else if stepSize < 1 {
                    runJumpFloodStep(2)
                    runJumpFloodStep(1)
                }
            }
        }

        _simulationStepper()

        # point = point.clone
        # point.x = Math.max(Math.min(point.x, gridSize), 0)
        # point.y = Math.max(Math.min(point.y, gridSize), 0)

        # # Draw a single pixel at point
        # const sample = Float32Array.new([1])
        # setCellGrid(sample, point.x as int, point.y as int)
    }

    def setCellGrid(inputGrid Float32Array, offsetX int, offsetY int) {
        const textureWidth = (Math.sqrt(inputGrid.length) as int)
        const textureHeight = textureWidth
        var rgba = Float32Array.new(textureWidth * textureWidth * 4)
        for i in 0..inputGrid.length {
            var j = i * 4
            rgba[j + 0] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 1] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 2] = inputGrid[i] > 0.5 ? 1.0 : 0.0
            rgba[j + 3] = 1.0
        }
        _sourceTexture.subset(rgba, offsetX, offsetY, textureWidth, textureHeight)
    }

    def swapBuffers {
        # Swap the source and destination textures
        const tmp = _sourceTexture
        _sourceTexture = _destTexture
        _destTexture = tmp
    }

    def runJumpFloodStep(stepSize int) {
        console.log("Running jump flood step with size \(stepSize)")
        # The current simulation state is always in _sourceTexture
        # and we draw onto _destTexture. So...
        #
        # 1. Bind the _destTexture onto the framebuffer so that
        #    we'll draw onto it.
        #
        # 2. Bind _sourceTexture texture to index 0. This is
        #    passed to the shader by setting the
        #    cellGridTexture uniform below.
        #
        _framebuffer.attach(_destTexture)

        if !RELEASE {
            const gl = _igloo.gl
            var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER)
            if check != gl.FRAMEBUFFER_COMPLETE {
                throw Error.new("Framebuffer completion issue")
            }
        }

        _sourceTexture.bind(0)
        _igloo.gl.viewport(0, 0, gridSize, gridSize)
        _program
            .use
            .attrib("quad", _quadBuffer, 2)
            .uniformi("cellGridTexture", 0)
            .uniformi("stepSize", stepSize)
            .uniform("cellGridSize", Float32Array.new([gridSize, gridSize]))
            .draw(_igloo.gl.TRIANGLE_STRIP, 4)

        self.swapBuffers
    }

    def computeVoronoi {
        var stepSize int = gridSize / 2
        while stepSize >= 1 {
            runJumpFloodStep(stepSize)
            stepSize /= 2
        }
        runJumpFloodStep(2)
        runJumpFloodStep(1)
    }
}