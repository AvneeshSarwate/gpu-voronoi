# Base class for mouse interactions
interface MouseBehavior {
    def down(x int, y int)
    def move(x int, y int)
    def up(x int, y int)
    def scroll(x int, y int, deltaX double, deltaY double)
}

# Base class for touch interactions
interface TouchHandler {
    def touchStart(e HTMLTouchEvent)
    def touchMove(e HTMLTouchEvent)
    def touchEnd(e HTMLTouchEvent)
}

def canvasSpaceToGridSpace(canvasPosition Vector, canvasSize Vector, viewport Rect) Vector {
    const canvasSpaceUv = canvasPosition / canvasSize
    return viewport.pointAtUvCoordinate(canvasSpaceUv)
}

def canvasSpaceToGridSpace(canvasPosition Vector, controller Controller) Vector {
    return canvasSpaceToGridSpace(
        canvasPosition,
        Vector.new(controller.canvas.width, controller.canvas.height),
        controller.viewport
    )
}

############################################################################
#
#                          Mouse Interactions
#
############################################################################

class ClickDragMouseBehavior :: MouseBehavior {
    var _controller Controller

    var _onDownGridSpace Vector = null
    var _onDownViewport Rect = null

    def down(x int, y int) {
        _onDownViewport = _controller.viewport.clone
        _onDownGridSpace = _canvasSpaceToGridSpace(x, y)
    }

    def move(x int, y int) {
        if _onDownGridSpace == null {
            return
        }
        const onMoveGridSpace = _canvasSpaceToGridSpace(x, y)
        const delta = _delta(onMoveGridSpace)
        _controller.viewport.origin = _onDownViewport.origin + delta
        _controller.setCanvasCursor("move")
    }

    def up(x int, y int) {
        if _onDownGridSpace != null {
            const onUpGridSpace = _canvasSpaceToGridSpace(x, y)
            const delta = _delta(onUpGridSpace)
            if delta.length > 10 {
                _controller.viewport.origin = _onDownViewport.origin + delta
            } else {
                # Treat it as a click
                _controller.userClickGridSpace(_onDownGridSpace)
            }
        }

        _onDownGridSpace = null
        _onDownViewport = null
        _controller.setCanvasCursor("default")
    }

    def scroll(x int, y int, deltaX double, deltaY double) { }

    def _canvasSpaceToGridSpace(x int, y int) Vector {
        y = _controller.canvasSize.y as int - y
        if _onDownViewport == null {
            throw Error.new("Shouldn't call _gridSpaceFromCanvasSpace unless _onDownViewport is set")
        }

        return canvasSpaceToGridSpace(
            Vector.new(x, y),
            Vector.new(_controller.canvas.width, _controller.canvas.height),
            _onDownViewport
        )
    }

    def _delta(newLocation Vector) Vector {
        if _onDownGridSpace == null {
            throw Error.new("Shouldn't call _delta unless _onDownGridSpace is set")
        }

        return _onDownGridSpace - newLocation
    }
}

############################################################################

class ZoomMouseBehavior :: MouseBehavior {
    var _controller Controller

    def down(x int, y int) {}
    def move(x int, y int) {}
    def up(x int, y int) {}

    def scroll(x int, y int, deltaX double, deltaY double) {
        _controller.viewport = Zoom.zoomViewport(
            _controller.viewport,
            deltaY,
            Vector.new(x, y),
            _controller.canvasSize
        )
    }
}

############################################################################
#
#                          Touch Interactions
#
############################################################################

class PanTouchHandler :: TouchHandler {
    var _controller Controller
    var _panning = false
    var _dragBehavior ClickDragMouseBehavior = null

    def touchStart(e HTMLTouchEvent) {
        # Start panning if there's just a single touch
        _panning = e.touches.count == 1

        if _panning {
            _dragBehavior = ClickDragMouseBehavior.new(_controller)
            _dragBehavior.down(e.touches[0].clientX, e.touches[0].clientY)
        }

        e.preventDefault
    }

    def touchMove(e HTMLTouchEvent) {
        # If we were panning, keep panning if we still have just one touch
        _panning = _panning && e.touches.count == 1

        if _panning {
            _dragBehavior.move(e.touches[0].clientX, e.touches[0].clientY)
        }

        e.preventDefault
    }

    def touchEnd(e HTMLTouchEvent) {
        # If we were panning, keep panning if we still have just one touch
        _panning = _panning && e.touches.count == 1

        if _panning {
            _dragBehavior.up(e.touches[0].clientX, e.touches[0].clientY)
        }
        _panning = false

        e.preventDefault
    }
}

############################################################################

class ZoomTouchHandler :: TouchHandler {
    var _controller Controller
    var _scaling = false

    var _onStartDistance Box<double> = null
    var _onStartViewport Rect = null

    def touchStart(e HTMLTouchEvent) {
        if e.touches.count == 2 {
            _scaling = true
            _onStartViewport = _controller.viewport
            _onStartDistance = Box<double>.new(_distanceBetweenTouches(e))
        }
    }

    def touchMove(e HTMLTouchEvent) {
        if _onStartViewport != null && e.touches.count == 2 {
            _onZoom(e)
        }
    }

    def touchEnd(e HTMLTouchEvent) {
        if _onStartViewport != null && e.touches.count == 2 {
            _onZoom(e)
            _onStartViewport = null
        }
    }

    def _distanceBetweenTouches(e HTMLTouchEvent) double {
        const aTouch = e.touches[0]
        const bTouch = e.touches[1]
        const a = Vector.new(aTouch.clientX, aTouch.clientY)
        const b = Vector.new(bTouch.clientX, bTouch.clientY)
        return a.distanceTo(b)
    }

    def _touchCenter(e HTMLTouchEvent) Vector {
        const aTouch = e.touches[0]
        const bTouch = e.touches[1]
        const a = Vector.new(aTouch.clientX, aTouch.clientY)
        const b = Vector.new(bTouch.clientX, bTouch.clientY)
        return (a + b) / 2.0
    }

    def _onZoom(e HTMLTouchEvent) {
        assert(_onStartViewport != null)
        assert(_onStartDistance != null)

        _controller.viewport = Zoom.zoomViewport(
            _onStartViewport,
            _onStartDistance.value - _distanceBetweenTouches(e),
            _touchCenter(e),
            _controller.canvasSize
        )
    }
}



