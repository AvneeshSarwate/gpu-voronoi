
namespace Controller {
    var gridSize = 512
}

class Controller {
    var _inputCanvas HTMLCanvasElement
    var _outputCanvas HTMLCanvasElement
    var _simulation JumpFlood
    var _igloo Igloo

    var _program Igloo.Program
    var _quadBuffer Igloo.Buffer

    var _mouseBehaviors List<MouseBehavior>
    var _touchHandlers List<TouchHandler>

    # viewport in grid-space
    var viewport Rect

    def new(inputCanvas HTMLCanvasElement, outputCanvas HTMLCanvasElement) {
        _inputCanvas = inputCanvas
        const paintController = PaintCanvasController.new(_inputCanvas)
        paintController.onDraw = () => {
            _simulation.setSeedsFromCanvas(_inputCanvas)
            _simulation.computeVoronoi
        }

        _outputCanvas = outputCanvas
        viewport = Rect.new(-50, -10, 180, 180)

        _igloo = Igloo.new(_outputCanvas)
        if _igloo.gl == null {
            document.getElementById("app-container").style.display = "none"
            document.getElementById("webgl-error").style.display = null
            throw Error.new("Failed to initialize Igloo")
        }

        _simulation = JumpFlood.new(_igloo, gridSize)
        #_simulation.computeVoronoi
        _igloo.gl.disable(_igloo.gl.DEPTH_TEST)
        _program = Igloo.Program.new(_igloo.gl, GLSLX_SOURCE_V_COPY_POSITION, GLSLX_SOURCE_F_DRAW_GRID)
        _quadBuffer = _igloo.array(Igloo.QUAD2)

        _mouseBehaviors = [
            ClickDragMouseBehavior.new(self),
            ZoomMouseBehavior.new(self)
         ]

         _touchHandlers = [
             PanTouchHandler.new(self),
             ZoomTouchHandler.new(self)
         ]

        _bindMouseBehaviors
        _onResize
        window.addEventListener("resize", () => { _onResize })
        document.getElementById("compute-button").addEventListener("mouseup", (e HTMLMouseEvent) => {
            _simulation.setSeedsFromCanvas(_inputCanvas)
        })
    }

    def setCanvasCursor(cssCursor string) {
        _outputCanvas.style.cursor = cssCursor
    }

    def _onResize {
        const canvasContainer dynamic = document.getElementById("canvas-container")
        _outputCanvas.width = canvasContainer.offsetWidth
        _outputCanvas.height = canvasContainer.offsetHeight

        # Constrain the viewport size to the same aspect ratio
        # as the canvas
        viewport.size.constrainToAspectRatio(Vector.new(_outputCanvas.width, _outputCanvas.height), Axis.Y)

        if !RELEASE {
            const viewportAspectRatio = viewport.size.y / viewport.size.x
            const canvasAspectRatio = _outputCanvas.height as double / _outputCanvas.width
            assert(viewportAspectRatio - canvasAspectRatio < 0.001)
        }
    }

    def canvas HTMLCanvasElement {
        return _outputCanvas
    }

    def canvasSize Vector {
        return Vector.new(_outputCanvas.width, _outputCanvas.height)
    }

    def userClickGridSpace(point Vector) {
        _simulation.userClickGridSpace(point)
    }

    def draw {
        # As per the comment at the top of 'step', the current grid
        # state is stored in the 'front' texture. So we bind that to
        # index 0 and pass that to the shader as cellGridTexture.
        _igloo.defaultFramebuffer.bind
        _simulation.gridTexture.bind(0)
        _igloo.gl.viewport(0, 0, _outputCanvas.width, _outputCanvas.height)
        _program
            .use
            .attrib("quad", _quadBuffer, 2)
            .uniformi("iCellGridTexture", 0)
            .uniform("iViewportOffset", viewport.origin.toFloat32Array)
            .uniform("iViewportSize", viewport.size.toFloat32Array)
            .uniform("iCanvasSize", Float32Array.new([_outputCanvas.width, _outputCanvas.height]))
            .uniform("iGridSize", Float32Array.new([_simulation.gridSize, _simulation.gridSize]))
            .uniform("iRelease", RELEASE, true)
            .draw(_igloo.gl.TRIANGLE_STRIP, 4)
    }

    def start {
        setInterval(() => {
            draw
        }, 60)
    }

    def _bindMouseBehaviors {
        _outputCanvas.addEventListener("mousedown", (e HTMLMouseEvent) => {
            for behavior in _mouseBehaviors {
                behavior.down(e.offsetX, e.offsetY)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("mousemove", (e HTMLMouseEvent) => {
            for behavior in _mouseBehaviors {
                behavior.move(e.offsetX, e.offsetY)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("mouseup", (e HTMLMouseEvent) => {
            for behavior in _mouseBehaviors {
                behavior.up(e.offsetX, e.offsetY)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("mouseleave", (e HTMLMouseEvent) => {
            for behavior in _mouseBehaviors {
                behavior.up(e.offsetX, e.offsetY)
            }
        })

        _outputCanvas.addEventListener("wheel", (e HTMLWheelEvent) => {
            for behavior in _mouseBehaviors {
                behavior.scroll(e.offsetX, e.offsetY, e.deltaX, e.deltaY)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("touchstart", (e HTMLTouchEvent) => {
            for touchHandler in _touchHandlers {
                touchHandler.touchStart(e)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("touchmove", (e HTMLTouchEvent) => {
            for touchHandler in _touchHandlers {
                touchHandler.touchMove(e)
            }
            e.preventDefault
        })

        _outputCanvas.addEventListener("touchend", (e HTMLTouchEvent) => {
            for touchHandler in _touchHandlers {
               touchHandler.touchEnd(e)
            }
            e.preventDefault
        })
    }
}