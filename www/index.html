<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- From here: http://stackoverflow.com/a/4389976 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Voronoi GPU</title>
    <link href='https://fonts.googleapis.com/css?family=Lato:300,700italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="style.css">
    <script src="demo-compiled.js"></script>
  </head>
  <body>
    <div id="demo-page">
      <h1>Voronoi Diagrams on the GPU</h1>

      <hr>

      <p class="disclaimer">
        Disclaimer: the demos on this page use WebGL features that aren't available on many mobile devices. For the best experience, read this on a Desktop computer.
      </p>

      <hr>

      <p>
        This page has a few demos of some code that I wrote to generate Voronoi diagrams. If you're interested, you can find the code <a target="blank_" href="https://github.com/ryankaplan/gpu-voronoi">here</a>.
      </p>

      <p>
        What is a Voronoi diagram? Try the demo below to find out. When you click in the left canvas, you plant a colored 'seed'. In the right canvas, every pixel takes the color of the closest seed.
      </p>

      <div id="paint-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        Here's another demo that's slightly more interactive. Move your mouse over either canvas.
      </p>

      <div id="fish-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        And below is one more example. In the left canvas there are seeds in a radial pattern overlaid on top of a photo. Each seed takes the color of the underlying pixel in the image. Move the circle to move the seeds and move the square to rotate them.
      </p>

      <div id="photo-demo-container" class="demo-container">
        <div class="input-canvas-container">
          <img id="eye" src="images/eye.jpg"></img>
          <canvas class="input-canvas"></canvas>
        </div>
        <canvas class="output-canvas"></canvas>
      </div>

      <h2>
        How does this work?
      </h2>

      <p>
        There are a few other popular algorithms for computing Voronoi diagrams. If you're interested in a survey you can read <a href="http://www.alanzucconi.com/2015/02/24/to-voronoi-and-beyond/" target="blank_">this article</a>. But I'll talk about one that I used above. I think it's really cool and it's called Jump Flooding (you can skip this explanation and see the paper <a href="http://www.comp.nus.edu.sg/~tants/jfa.html" target="blank_">here</a>).
      </p>

      <p>
        Suppose we're building a Voronoi diagram and we're trying to figure out the color of the top left pixel of an image. One way to do it would be as follows. First, look at the pixels that are direct neighbours. If any of them are seeds, and are closer than any seeds you've seen so far, remember their location. Then do the same for those pixels neighbours, and then those neighbours and so on.
      </p>

      <p>
          Here's a gif to show how this might work.
      </p>

      <div style="width: 100%; text-align: center;">
        <img src="images/naive.gif" alt="" />
      </div>

      <p>
          For each pixel we end up looking at every other pixel in the grid. This is pretty expensive, and you can probably get away with less. How about if, instead of working your way outward from the pixel that you're looking for, you shoot rays out of the current pixel in a radial pattern. Something like this:
      </p>

      <div style="width: 100%; text-align: center;">
        <img src="images/ray.gif" alt="" />
      </div>

      <p>
          Now instead of doing N x N lookups for every pixel, you're doing approximately 4 N. And it's not clear that this always gives you the correct result. Jump Flood is similar to this approach, but does even fewer lookups. It too moves outward in a ray-like pattern, but it does so in exponentially bigger jumps. See the gif below.
      </p>

      <div style="width: 100%; text-align: center;">
        <img src="images/jfa.gif" alt="" />
      </div>

      <p>
          This means that for each pixel you do approximately 8 log(N) work. In practice that's not very much which is why the demos on this page run quickly.
      </p>

      <p>
          JFA actually works backward though.
      </p>


      <div style="width: 100%; text-align: center;">
        <img src="images/backwards-jfa.gif" alt="" />
      </div>


      <h2>
          Other Applications of Jump Flooding
      </h2>

      <p>
        In the demos up top we use the Jump Flooding algorithm to draw Voronoi diagrams. For each pixel we calculate the color of the closest seed and the distance to the closest seed. The Jump Flooding algorithm gives us something else that we didn't draw: the distance to the closest seed. Below is a demo where the color of the pixel changes based on the distance to the closest seed. Bright pixels are close to a seed and dark pixels are far from a seed.
      </p>

      <div id="distance-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        We can use this to implement 'outlines' on shapes. Below is a demo of a rectangle - you can drag it to move it around. In the right canvas, we've run the Jump Flooding algorithm and we draw pixels that are within 10px of an seed (aka any pixel in the square). What we get is a square with an outline.
      </p>

      <div id="threshold-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

    </div>
    <div id="webgl-error" style="display: none;">
      This webpage uses WebGL which isn't supported by your browser. <br />
      </br>
      Sorry :(
    </div>
  </body>
</html>