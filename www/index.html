<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <!-- From here: http://stackoverflow.com/a/4389976 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Voronoi GPU</title>
    <link rel="stylesheet" href="nouislider.css">
    <link rel="stylesheet" href="style.css">
    <script src="nouislider.min.js" ></script>
    <script src="demo-compiled.js"></script>
  </head>
  <body>
    <div id="demo-page">
      <h1>Voronoi Diagrams on the GPU</h1>

      <hr>

      <p class="disclaimer">
        The demos on this page use WebGL features that aren't available on many mobile devices. For the best experience, read this on a Desktop computer.
      </p>

      <hr>

      <p>
        What is a Voronoi diagram? Try the demo below to find out. When you click in the left canvas, you plant a colored &lsquo;seed&rsquo;. In the right canvas, every pixel takes the color of the closest seed. You can drag to plant lots of seeds.
      </p>

      <div id="paint-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        Demo #2: on the left is a scene with a few moving dots. On the right is the corresponding Voronoi diagram. Move your mouse over either canvas to control the location of the yellow dot. I like to pretend that it's a yellow fish swimming in water.
      </p>

      <div id="fish-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        Here's one more demo that I think is fun. In the left canvas there are seeds in a radial pattern overlaid on top of a photo. Each seed takes the color of the underlying pixel in the image. Move the circular handle to move the seeds and move the square handle to rotate them.
      </p>

      <div id="photo-demo-container" class="demo-container">
        <div class="input-canvas-container">
          <img id="eye" src="images/eye.jpg"></img>
          <canvas class="input-canvas"></canvas>
        </div>
        <canvas class="output-canvas"></canvas>
      </div>

      <h2>
        How does it work?
      </h2>

      <p>
        There are a few popular algorithms for computing Voronoi diagrams. I'll talk about the one that I used to build the demos above (you can find the code for them <a target="blank_" href="https://github.com/ryankaplan/gpu-voronoi">here</a>). The approach is from a paper called <a href="http://www.comp.nus.edu.sg/~tants/jfa.html" target="blank_">Jump Flooding in GPU with Applications to Voronoi Diagram and Distance Transform</a>. We'll call it JFA - short for Jump Flooding Algorithm.
     </p>

      <p>
        The input to JFA is a blank background with some colored seeds on it (like the input canvas in the first demo above). You iterate over the image in <i>rounds</i>, each with a <i>step length</i>, k. In a given round you iterate through each pixel (i, j) and look at 8 pixels around it. The 8 pixels that you look at aren't the immediate neighbours. They depend on the step length of the round that you're in. If your round has step length k, then you look at nearby pixels in the pattern shown in the diagram below.
      </p>

      <div style="width: 100%; text-align: center;">
          <div style="margin: auto; max-width: 400px;">
            <img style="width: 100%; height: 100%;" src="images/step-k.svg" alt="">
            <div class="image-caption">For each pixel that you process, you look for seeds in each cardinal and intercardinal direction.</div>
          </div>
      </div>

      <p>
        If your round has step length 1, then you look at your immediate neighbours. But if your step length is 10, then you look 10 pixels North, North-West, West, South-West, etc.
      </p>

      <p>
        At each stage of JFA, each pixel remembers the closest seed that it's seen so far. So when you visit new pixels in the pattern described above, you check to see if the pixel you're visiting knows about a closer seed than the closest one you've found so far.
      </p>

      <p>
        The first round of JFA has step length N / 2, where N is the size of the grid. The next one has step length N / 4. The following has N / 8, and so on until N / k is 1. In total there are log(N) rounds. Below is an interactive demo showing the pattern in which JFA moves through the grid for each round. At each step, it shows the grid cell that we're currently processing and the 8 cells around it that it visits to look for seeds. Use the slider to change which round you're on.
      </p>

      <div id="jfa-pattern-demo-container" class="demo-container">
        <canvas></canvas>
        <div class="step-size-label label" ></div>
        <div class="step-size-slider" ></div>
      </div>

      <p>
          To summarize, JFA works as follows: you walk through every pixel in the grid log(N) times. The first time, you look for seeds in the 8 &lsquo;neighbours&rsquo; roughly N / 2 pixels away from the current pixel. The next round you look at the neighbours roughly N / 4 pixels away, and so on. Every pixel holds on to the closest seed that it's found so far and during the course of the algorithm passes that information on to other cells in the grid.
      </p>

      <p>
          It's interesting to see what the JFA grid looks like at the end of each round. Below is a demo like the one at the top of the page, except there's a slider to set the maximum JFA round number. If you set it to 5, then we stop computing JFA at round 5 and show the result in the second canvas. Try adding a few seeds and moving the slider slowly from round 0 to see what JFA does at each step. I find it really interesting how it all comes together in the last two steps -- before that it doesn't look much like a Voronoi diagram at all.
      </p>

      <div id="slider-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
        <div class="demo-controls">
            <span class="jfa-round-label label"></span><div class="jfa-round-slider" />
        </div>
      </div>

      <h2>
        Distance fields
      </h2>

      <p>
        JFA gives us two things for every pixel: the color of the closest seed, and the location of the closest seed. I used the color of the closest seed in the demos above. Below is a demo that colors pixels by how far they are from the closest seed. A bright pixel means its close to a seed.
      </p>

      <div id="distance-demo-container" class="demo-container">
        <canvas class="input-canvas"></canvas>
        <canvas class="output-canvas"></canvas>
      </div>

      <p>
        We can use this to build drop shadows for artbitrary shapes. One of the tricky parts of rendering drop shadows (in CSS) is that they have a "spread" value. The bigger the spread, the farther the shadow reaches before fading out. This means that you can't implement a drop shadow just by blurring the shape casting the shadow.
      </p>

      <p>
          We use JFA to generate a distance field - each pixel in the shape casting the shadow is a &lsquo;seed&rsquo; our JFA input. The distance field tells us how far away each pixel is from the geometry casting the shadow. When the spread is big, we know that we should blur shadow pixels only if they're far from the geometry, and vice versa.
      </p>

      <div id="shadow-demo-container" class="demo-container">
        <canvas class="input-canvas" style="display: none;"></canvas>
        <canvas class="output-canvas"></canvas>
        <div class="shadow-spread-controls">
            <span class="shadow-spread-label label">Spread</span><div class="shadow-spread-slider" ></div>
        </div>
        <div class="shadow-blur-controls">
            <span class="shadow-blur-label label">Blur</span><div class="shadow-blur-slider" ></div>
        </div>
      </div>

      <p>
          You can drag the canvas above the move the drop shadow, or use the sliders to control spread and blur.
      </p>

    </div>
    <div id="webgl-error" style="display: none;">
      This webpage uses WebGL which isn't supported by your browser. <br />
      </br>
      Sorry :(
    </div>
  </body>
</html>